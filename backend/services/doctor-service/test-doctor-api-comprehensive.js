#!/usr/bin/env node

/**
 * üß™ COMPREHENSIVE DOCTOR SERVICE API TESTS
 * 
 * Tests all Doctor Service endpoints with enhanced validation
 * - CRUD operations (5 tests)
 * - Schedule management (3 tests) 
 * - Review system (2 tests)
 * - Search & filtering (3 tests)
 * - Performance tests (2 tests)
 * 
 * Total: 15 tests for 100% API coverage
 */

const axios = require('axios');
const crypto = require('crypto');

// Configuration
const DOCTOR_SERVICE_URL = process.env.DOCTOR_SERVICE_URL || 'http://localhost:3002';
const API_GATEWAY_URL = process.env.API_GATEWAY_URL || 'http://localhost:3100';
const AUTH_SERVICE_URL = process.env.AUTH_SERVICE_URL || 'http://localhost:3001';

// Test Statistics
let testStats = {
  total: 0,
  passed: 0,
  failed: 0,
  startTime: Date.now(),
  endTime: null,
  results: []
};

// Test Data - Department-based ID system format
const testDoctor = {
  full_name: `Dr. Test ${crypto.randomBytes(4).toString('hex')}`, // Required field
  specialty: 'Tim m·∫°ch', // DEPT001 = CARD = Tim m·∫°ch
  qualification: 'Th·∫°c sƒ© Y khoa', // Match existing qualification
  department_id: 'DEPT001', // DEPT001 = CARD (Tim m·∫°ch) - should generate CARD-DOC-202506-XXX
  license_number: `VN-CARD-${Date.now().toString().slice(-4)}`, // Department-based license
  gender: 'male',
  bio: 'B√°c sƒ© tim m·∫°ch test v·ªõi nhi·ªÅu nƒÉm kinh nghi·ªám',
  experience_years: 5,
  consultation_fee: 500000,
  languages_spoken: ['Vietnamese'],
  availability_status: 'available'
  // Expected generated doctor_id: CARD-DOC-202506-001 (department-based format)
  // Note: profile_id will be auto-generated by create_doctor function
};

let createdDoctorId = null;
let authToken = null;

// Utility Functions
function log(message, color = 'white') {
  const colors = {
    red: '\x1b[31m',
    green: '\x1b[32m',
    yellow: '\x1b[33m',
    blue: '\x1b[34m',
    magenta: '\x1b[35m',
    cyan: '\x1b[36m',
    white: '\x1b[37m',
    reset: '\x1b[0m'
  };
  console.log(`${colors[color]}${message}${colors.reset}`);
}

function addTestResult(testName, success, message, duration = 0, data = null) {
  testStats.total++;
  if (success) {
    testStats.passed++;
    log(`‚úÖ ${testName}: PASSED (${duration}ms)`, 'green');
  } else {
    testStats.failed++;
    log(`‚ùå ${testName}: FAILED - ${message}`, 'red');
  }
  
  testStats.results.push({
    test: testName,
    success,
    message,
    duration,
    data: data ? JSON.stringify(data, null, 2) : null,
    timestamp: new Date().toISOString()
  });
}

async function makeRequest(method, endpoint, data = null, useGateway = true) {
  const baseUrl = useGateway ? API_GATEWAY_URL : DOCTOR_SERVICE_URL;
  const url = `${baseUrl}${endpoint}`;
  const startTime = Date.now();
  
  try {
    const config = {
      method,
      url,
      headers: {
        'Content-Type': 'application/json',
        ...(authToken && { 'Authorization': `Bearer ${authToken}` })
      },
      ...(data && { data }),
      timeout: 30000 // Increase timeout for create operations
    };
    
    const response = await axios(config);
    const duration = Date.now() - startTime;
    
    return {
      success: true,
      data: response.data,
      status: response.status,
      duration
    };
  } catch (error) {
    const duration = Date.now() - startTime;
    return {
      success: false,
      error: error.response?.data?.message || error.message,
      status: error.response?.status || 0,
      duration
    };
  }
}

// Authentication Helper
async function authenticateTestUser() {
  try {
    log('\nüîê Authenticating test user...', 'cyan');
    
    // Create test admin user
    const adminUser = {
      email: `admin.test.${crypto.randomBytes(4).toString('hex')}@hospital.com`,
      password: 'TestPassword123!',
      full_name: 'Test Admin',
      role: 'admin'
    };
    
    // Register admin
    const registerResult = await makeRequest('POST', '/api/auth/signup', adminUser, true);
    if (!registerResult.success) {
      log(`Registration failed: ${registerResult.error}`, 'red');
      return false;
    }

    // Login admin
    const loginResult = await makeRequest('POST', '/api/auth/signin', {
      email: adminUser.email,
      password: adminUser.password
    }, true);
    
    if (loginResult.success && (loginResult.data.token || loginResult.data.access_token)) {
      authToken = loginResult.data.token || loginResult.data.access_token;
      log('‚úÖ Authentication successful', 'green');
      return true;
    } else {
      log(`Login failed: ${loginResult.error}`, 'red');
      return false;
    }
  } catch (error) {
    log(`Authentication error: ${error.message}`, 'red');
    return false;
  }
}

// Test Functions

// 1. CRUD Operations Tests (5 tests)
async function testHealthCheck() {
  log('\n1Ô∏è‚É£ Testing Health Check', 'yellow');
  const result = await makeRequest('GET', '/health', null, false);
  
  if (result.success && result.status === 200) {
    addTestResult('Health Check', true, 'Service is healthy', result.duration);
    return true;
  } else {
    addTestResult('Health Check', false, result.error, result.duration);
    return false;
  }
}

async function testCreateDoctor() {
  log('\n2Ô∏è‚É£ Testing Create Doctor', 'yellow');
  const result = await makeRequest('POST', '/api/doctors', testDoctor, true);
  
  if (result.success && result.data.doctor_id) {
    createdDoctorId = result.data.doctor_id;
    addTestResult('Create Doctor', true, `Doctor created with ID: ${createdDoctorId}`, result.duration, result.data);
    return true;
  } else {
    addTestResult('Create Doctor', false, result.error, result.duration);
    return false;
  }
}

async function testGetAllDoctors() {
  log('\n3Ô∏è‚É£ Testing Get All Doctors', 'yellow');
  const result = await makeRequest('GET', '/api/doctors', null, true);
  
  if (result.success && Array.isArray(result.data.data)) {
    addTestResult('Get All Doctors', true, `Retrieved ${result.data.data.length} doctors`, result.duration);
    return true;
  } else {
    addTestResult('Get All Doctors', false, result.error, result.duration);
    return false;
  }
}

async function testGetDoctorById() {
  log('\n4Ô∏è‚É£ Testing Get Doctor by ID', 'yellow');
  
  if (!createdDoctorId) {
    addTestResult('Get Doctor by ID', false, 'No doctor ID available');
    return false;
  }
  
  const result = await makeRequest('GET', `/api/doctors/${createdDoctorId}`, null, true);
  
  if (result.success && result.data.doctor_id === createdDoctorId) {
    addTestResult('Get Doctor by ID', true, `Retrieved doctor: ${result.data.full_name}`, result.duration, result.data);
    return true;
  } else {
    addTestResult('Get Doctor by ID', false, result.error, result.duration);
    return false;
  }
}

async function testUpdateDoctor() {
  log('\n5Ô∏è‚É£ Testing Update Doctor', 'yellow');
  
  if (!createdDoctorId) {
    addTestResult('Update Doctor', false, 'No doctor ID available');
    return false;
  }
  
  const updateData = {
    experience_years: testDoctor.experience_years + 1,
    full_name: testDoctor.full_name + ' Updated'
  };
  
  const result = await makeRequest('PUT', `/api/doctors/${createdDoctorId}`, updateData, true);
  
  if (result.success) {
    addTestResult('Update Doctor', true, 'Doctor updated successfully', result.duration, result.data);
    return true;
  } else {
    addTestResult('Update Doctor', false, result.error, result.duration);
    return false;
  }
}

// 2. Schedule Management Tests (3 tests)
async function testCreateSchedule() {
  log('\n6Ô∏è‚É£ Testing Create Doctor Schedule', 'yellow');
  
  if (!createdDoctorId) {
    addTestResult('Create Schedule', false, 'No doctor ID available');
    return false;
  }
  
  const scheduleData = {
    doctor_id: createdDoctorId,
    day_of_week: 1, // Monday
    start_time: '09:00',
    end_time: '17:00',
    is_available: true
  };
  
  const result = await makeRequest('POST', '/api/schedules', scheduleData, true);
  
  if (result.success) {
    addTestResult('Create Schedule', true, 'Schedule created successfully', result.duration, result.data);
    return true;
  } else {
    addTestResult('Create Schedule', false, result.error, result.duration);
    return false;
  }
}

async function testGetDoctorSchedule() {
  log('\n7Ô∏è‚É£ Testing Get Doctor Schedule', 'yellow');
  
  if (!createdDoctorId) {
    addTestResult('Get Doctor Schedule', false, 'No doctor ID available');
    return false;
  }
  
  const result = await makeRequest('GET', `/api/doctors/${createdDoctorId}/schedule`, null, true);
  
  if (result.success) {
    addTestResult('Get Doctor Schedule', true, 'Schedule retrieved successfully', result.duration, result.data);
    return true;
  } else {
    addTestResult('Get Doctor Schedule', false, result.error, result.duration);
    return false;
  }
}

async function testUpdateSchedule() {
  log('\n8Ô∏è‚É£ Testing Update Doctor Schedule', 'yellow');
  
  if (!createdDoctorId) {
    addTestResult('Update Schedule', false, 'No doctor ID available');
    return false;
  }
  
  const updateData = {
    start_time: '08:00',
    end_time: '16:00'
  };
  
  const result = await makeRequest('PUT', `/api/doctors/${createdDoctorId}/schedule/1`, updateData, true);
  
  if (result.success) {
    addTestResult('Update Schedule', true, 'Schedule updated successfully', result.duration, result.data);
    return true;
  } else {
    addTestResult('Update Schedule', false, result.error, result.duration);
    return false;
  }
}

// 3. Review System Tests (2 tests)
async function testCreateReview() {
  log('\n9Ô∏è‚É£ Testing Create Doctor Review', 'yellow');
  
  if (!createdDoctorId) {
    addTestResult('Create Review', false, 'No doctor ID available');
    return false;
  }
  
  const reviewData = {
    doctor_id: createdDoctorId,
    patient_id: 'PAT-202406-001', // Mock patient ID
    rating: 5,
    comment: 'Excellent doctor, very professional and caring.',
    appointment_date: new Date().toISOString().split('T')[0]
  };
  
  const result = await makeRequest('POST', '/api/reviews', reviewData, true);
  
  if (result.success) {
    addTestResult('Create Review', true, 'Review created successfully', result.duration, result.data);
    return true;
  } else {
    addTestResult('Create Review', false, result.error, result.duration);
    return false;
  }
}

async function testGetDoctorReviews() {
  log('\nüîü Testing Get Doctor Reviews', 'yellow');
  
  if (!createdDoctorId) {
    addTestResult('Get Doctor Reviews', false, 'No doctor ID available');
    return false;
  }
  
  const result = await makeRequest('GET', `/api/doctors/${createdDoctorId}/reviews`, null, true);
  
  if (result.success) {
    addTestResult('Get Doctor Reviews', true, 'Reviews retrieved successfully', result.duration, result.data);
    return true;
  } else {
    addTestResult('Get Doctor Reviews', false, result.error, result.duration);
    return false;
  }
}

// 4. Search & Filtering Tests (3 tests)
async function testSearchDoctorsBySpecialty() {
  log('\n1Ô∏è‚É£1Ô∏è‚É£ Testing Search Doctors by Specialty', 'yellow');

  const result = await makeRequest('GET', '/api/doctors?specialty=Tim%20m·∫°ch', null, true);

  if (result.success && Array.isArray(result.data.data)) {
    addTestResult('Search by Specialty', true, `Found ${result.data.data.length} doctors`, result.duration);
    return true;
  } else {
    addTestResult('Search by Specialty', false, result.error, result.duration);
    return false;
  }
}

async function testSearchDoctorsByName() {
  log('\n1Ô∏è‚É£2Ô∏è‚É£ Testing Search Doctors by Name', 'yellow');
  
  const result = await makeRequest('GET', `/api/doctors?search=${encodeURIComponent('Dr.')}`, null, true);
  
  if (result.success && Array.isArray(result.data.data)) {
    addTestResult('Search by Name', true, `Found ${result.data.data.length} doctors`, result.duration);
    return true;
  } else {
    addTestResult('Search by Name', false, result.error, result.duration);
    return false;
  }
}

async function testFilterDoctorsByExperience() {
  log('\n1Ô∏è‚É£3Ô∏è‚É£ Testing Filter Doctors by Experience', 'yellow');
  
  const result = await makeRequest('GET', '/api/doctors?min_experience=5', null, true);
  
  if (result.success && Array.isArray(result.data.data)) {
    addTestResult('Filter by Experience', true, `Found ${result.data.data.length} experienced doctors`, result.duration);
    return true;
  } else {
    addTestResult('Filter by Experience', false, result.error, result.duration);
    return false;
  }
}

// 5. Performance Tests (2 tests)
async function testResponseTime() {
  log('\n1Ô∏è‚É£4Ô∏è‚É£ Testing API Response Time', 'yellow');
  
  const startTime = Date.now();
  const result = await makeRequest('GET', '/api/doctors', null, true);
  const responseTime = Date.now() - startTime;
  
  if (result.success && responseTime < 500) {
    addTestResult('Response Time Test', true, `Response time: ${responseTime}ms (< 500ms)`, responseTime);
    return true;
  } else {
    addTestResult('Response Time Test', false, `Slow response: ${responseTime}ms (>= 500ms)`, responseTime);
    return false;
  }
}

async function testConcurrentRequests() {
  log('\n1Ô∏è‚É£5Ô∏è‚É£ Testing Concurrent Requests', 'yellow');
  
  const startTime = Date.now();
  const promises = Array(5).fill().map(() => 
    makeRequest('GET', '/api/doctors', null, true)
  );
  
  try {
    const results = await Promise.all(promises);
    const duration = Date.now() - startTime;
    const allSuccessful = results.every(r => r.success);
    
    if (allSuccessful) {
      addTestResult('Concurrent Requests', true, `5 concurrent requests completed in ${duration}ms`, duration);
      return true;
    } else {
      addTestResult('Concurrent Requests', false, 'Some concurrent requests failed', duration);
      return false;
    }
  } catch (error) {
    const duration = Date.now() - startTime;
    addTestResult('Concurrent Requests', false, error.message, duration);
    return false;
  }
}

// Main Test Runner
async function runComprehensiveTests() {
  log('üöÄ Starting Comprehensive Doctor Service API Tests', 'cyan');
  log('=' .repeat(60), 'cyan');
  
  testStats.startTime = Date.now();
  
  try {
    // Authentication
    const authSuccess = await authenticateTestUser();
    if (!authSuccess) {
      log('‚ùå Authentication failed. Aborting tests.', 'red');
      return;
    }
    
    // Run all tests
    await testHealthCheck();
    await testCreateDoctor();
    await testGetAllDoctors();
    await testGetDoctorById();
    await testUpdateDoctor();
    
    await testCreateSchedule();
    await testGetDoctorSchedule();
    await testUpdateSchedule();
    
    await testCreateReview();
    await testGetDoctorReviews();
    
    await testSearchDoctorsBySpecialty();
    await testSearchDoctorsByName();
    await testFilterDoctorsByExperience();
    
    await testResponseTime();
    await testConcurrentRequests();
    
  } catch (error) {
    log(`üí• Unexpected error: ${error.message}`, 'red');
  }
  
  // Final Results
  testStats.endTime = Date.now();
  const totalDuration = testStats.endTime - testStats.startTime;
  
  log('\nüìä COMPREHENSIVE TEST RESULTS', 'cyan');
  log('=' .repeat(60), 'cyan');
  log(`Total Tests: ${testStats.total}`, 'white');
  log(`Passed: ${testStats.passed}`, 'green');
  log(`Failed: ${testStats.failed}`, 'red');
  log(`Success Rate: ${((testStats.passed / testStats.total) * 100).toFixed(1)}%`, 'yellow');
  log(`Total Duration: ${totalDuration}ms`, 'white');
  
  if (testStats.passed === testStats.total) {
    log('\nüéâ ALL TESTS PASSED! Doctor Service is ready for production.', 'green');
  } else {
    log('\n‚ö†Ô∏è  Some tests failed. Please review and fix issues.', 'yellow');
  }
  
  // Export results for external use
  return {
    summary: {
      total: testStats.total,
      passed: testStats.passed,
      failed: testStats.failed,
      successRate: ((testStats.passed / testStats.total) * 100).toFixed(1),
      duration: totalDuration
    },
    results: testStats.results,
    createdDoctorId
  };
}

// Export for external use
module.exports = {
  runComprehensiveTests,
  testStats
};

// Run tests if called directly
if (require.main === module) {
  runComprehensiveTests().catch(error => {
    console.error('‚ùå Test runner error:', error);
    process.exit(1);
  });
}
