'use client';

import { useEffect, useState } from 'react';
import { RefreshCw } from 'lucide-react';

interface AutoSyncResult {
    checked: number;
    updated: number;
    results: Array<{
        order_code: string;
        status: string;
        message: string;
    }>;
}

export default function AutoPaymentSync() {
    const [isSyncing, setIsSyncing] = useState<boolean>(false);
    const [lastSync, setLastSync] = useState<string | null>(null);
    const [syncCount, setSyncCount] = useState<number>(0);
    const [connectionStatus, setConnectionStatus] = useState<'connecting' | 'connected' | 'error'>('connecting');
    const [errorCount, setErrorCount] = useState(0);
    const [pauseSync, setPauseSync] = useState(false);
    const [recentPayments, setRecentPayments] = useState<string[]>([]);

    // ƒê·ªìng b·ªô thanh to√°n t·ª± ƒë·ªông m·ªói 8 gi√¢y
    useEffect(() => {
        const checkPaymentStatus = async () => {
            if (pauseSync) {
                console.log('‚è∏Ô∏è [Auto Sync] Paused. Skipping sync cycle.');
                return;
            }

            try {
                setIsSyncing(true);
                console.log('üîÑ [Auto Sync] Starting automatic payment synchronization...');

                // G·ªçi API ƒë·ªìng b·ªô thanh to√°n
                const response = await fetch('/api/payment/auto-sync', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        priorityOrderCodes: recentPayments
                    })
                });

                // X·ª≠ l√Ω k·∫øt qu·∫£
                if (response.ok) {
                    setConnectionStatus('connected');
                    setErrorCount(0);
                    const data = await response.json();

                    if (data.success && data.updated > 0) {
                        // Th√¥ng b√°o cho c√°c components kh√°c v·ªÅ vi·ªác ƒë·ªìng b·ªô th√†nh c√¥ng
                        window.dispatchEvent(new CustomEvent('paymentSyncUpdate', {
                            detail: {
                                count: data.updated,
                                timestamp: new Date().toISOString(),
                                updatedPayments: data.results || []
                            }
                        }));

                        // N·∫øu c√≥ thanh to√°n c·∫≠p nh·∫≠t th√†nh c√¥ng, hi·ªÉn th·ªã th√¥ng b√°o
                        if (data.updated > 0) {
                            console.log(`‚úÖ [Auto Sync] Updated ${data.updated} payments`);
                        }
                    }
                } else {
                    throw new Error(`API returned ${response.status}`);
                }

                // C·∫≠p nh·∫≠t th·ªùi gian ƒë·ªìng b·ªô cu·ªëi c√πng
                setLastSync(new Date().toISOString());
                setSyncCount(prev => prev + 1);
            } catch (error) {
                console.error('‚ùå [Auto Sync] Error:', error);
                setConnectionStatus('error');
                setErrorCount(prev => prev + 1);

                // Sau 5 l·ªói li√™n ti·∫øp, t·∫°m d·ª´ng ƒë·ªìng b·ªô
                if (errorCount >= 4) {
                    console.log('‚ö†Ô∏è [Auto Sync] Too many errors, pausing sync temporarily');
                    setPauseSync(true);

                    // T·ª± ƒë·ªông kh√¥i ph·ª•c sau 30 gi√¢y
                    setTimeout(() => {
                        setPauseSync(false);
                        setErrorCount(0);
                        console.log('üîÑ [Auto Sync] Resuming after pause');
                    }, 30000);
                }
            } finally {
                setIsSyncing(false);
            }
        };

        // Kh·ªüi t·∫°o interval
        const interval = setInterval(checkPaymentStatus, 4000); // 4 gi√¢y thay v√¨ 8 gi√¢y

        // Ch·∫°y l·∫ßn ƒë·∫ßu ti√™n ngay l·∫≠p t·ª©c 
        checkPaymentStatus();

        return () => clearInterval(interval);
    }, [pauseSync, errorCount, recentPayments]);

    // L·∫Øng nghe s·ª± ki·ªán ƒë·ªìng b·ªô cho thanh to√°n c·ª• th·ªÉ
    useEffect(() => {
        const handlePaymentSuccess = (event: CustomEvent) => {
            // Th√™m order code v√†o danh s√°ch ∆∞u ti√™n ƒë·ªìng b·ªô
            if (event.detail?.orderCode) {
                console.log('üîî [Auto Sync] Payment success event received:', event.detail.orderCode);
                setRecentPayments(prev => {
                    // Th√™m v√†o ƒë·∫ßu danh s√°ch v√† gi·ªØ t·ªëi ƒëa 5 thanh to√°n g·∫ßn nh·∫•t
                    const newList = [event.detail.orderCode, ...prev].slice(0, 5);
                    return newList;
                });

                // K√≠ch ho·∫°t ƒë·ªìng b·ªô ngay l·∫≠p t·ª©c
                setTimeout(async () => {
                    try {
                        console.log('üîÑ [Auto Sync] Immediate sync for new payment:', event.detail.orderCode);
                        const response = await fetch(`/api/payment/check-status?orderCode=${event.detail.orderCode}`, {
                            method: 'GET',
                            headers: {
                                'Content-Type': 'application/json'
                            },
                            cache: 'no-store',
                            next: { revalidate: 0 }
                        });

                        if (response.ok) {
                            const data = await response.json();
                            console.log('‚úÖ [Auto Sync] Immediate check result:', data);

                            // Th√¥ng b√°o c·∫≠p nh·∫≠t cho payment history page
                            window.dispatchEvent(new CustomEvent('specificPaymentUpdated', {
                                detail: {
                                    orderCode: event.detail.orderCode,
                                    status: data.status || 'updated',
                                    timestamp: new Date().toISOString()
                                }
                            }));
                        }
                    } catch (error) {
                        console.error('‚ùå [Auto Sync] Error during immediate sync:', error);
                    }
                }, 1000); // ƒê·ª£i 1 gi√¢y sau s·ª± ki·ªán th√†nh c√¥ng
            }
        };

        window.addEventListener('paymentSuccess', handlePaymentSuccess as EventListener);
        window.addEventListener('specificPaymentUpdated', (event: Event) => {
            const customEvent = event as CustomEvent;
            if (customEvent.detail?.orderCode) {
                console.log('üîî [Auto Sync] Payment specific update:', customEvent.detail.orderCode);
                // K√≠ch ho·∫°t ƒë·ªìng b·ªô cho thanh to√°n c·ª• th·ªÉ
                setRecentPayments(prev => {
                    // Th√™m v√†o ƒë·∫ßu danh s√°ch v√† gi·ªØ t·ªëi ƒëa 5 thanh to√°n g·∫ßn nh·∫•t
                    return [...new Set([customEvent.detail.orderCode, ...prev])].slice(0, 5);
                });
            }
        });

        return () => {
            window.removeEventListener('paymentSuccess', handlePaymentSuccess as EventListener);
            window.removeEventListener('specificPaymentUpdated', handlePaymentSuccess as EventListener);
        };
    }, []);

    // Ki·ªÉm tra xem c√≥ orderCode trong URL kh√¥ng ƒë·ªÉ ƒë·ªìng b·ªô thanh to√°n c·ª• th·ªÉ
    const checkAndSyncSpecificPayment = () => {
        if (typeof window === 'undefined') return;

        try {
            const url = new URL(window.location.href);
            const orderCode = url.searchParams.get('orderCode') || url.searchParams.get('order_code');

            if (orderCode) {
                console.log(`üîç [AutoSync] Found order code in URL: ${orderCode}, checking payment status`);
                checkSpecificPayment(orderCode);
            }
        } catch (error) {
            console.error('‚ùå [AutoSync] Error checking URL for order code:', error);
        }
    };

    // ƒê·ªìng b·ªô m·ªôt thanh to√°n c·ª• th·ªÉ theo orderCode
    const checkSpecificPayment = async (orderCode: string) => {
        try {
            console.log(`üîç [AutoSync] Checking specific payment: ${orderCode}`);
            const response = await fetch(`/api/payment/check-status?orderCode=${orderCode}`, {
                method: 'GET',
                headers: { 'Content-Type': 'application/json' }
            });

            if (!response.ok) {
                throw new Error(`API returned status ${response.status}`);
            }

            const result = await response.json();

            if (result.success) {
                console.log(`‚úÖ [AutoSync] Payment check result:`, result);

                // N·∫øu payment ƒë√£ ƒë∆∞·ª£c c·∫≠p nh·∫≠t, trigger m·ªôt event
                if (result.updated) {
                    console.log(`üîî [AutoSync] Payment ${orderCode} was updated to status: ${result.data?.status}`);
                    const updateEvent = new CustomEvent('specificPaymentUpdated', {
                        detail: {
                            orderCode,
                            status: result.data?.status,
                            timestamp: new Date().toISOString()
                        }
                    });
                    window.dispatchEvent(updateEvent);
                }
            } else {
                console.error(`‚ùå [AutoSync] Error checking payment ${orderCode}:`, result.error);
            }
        } catch (error) {
            console.error(`‚ùå [AutoSync] Error checking payment ${orderCode}:`, error);
        }
    };

    // Ch·∫°y recovery process ƒë·ªÉ kh√¥i ph·ª•c c√°c thanh to√°n thi·∫øu patient_id
    const runPaymentRecovery = async () => {
        try {
            // Ki·ªÉm tra s·ªë l∆∞·ª£ng thanh to√°n c·∫ßn kh√¥i ph·ª•c
            const checkResponse = await fetch('/api/payment/recover-missing');
            const checkData = await checkResponse.json();

            if (checkData.success && checkData.missing_count > 0) {
                console.log(`üîç [AutoSync] Found ${checkData.missing_count} payments needing recovery`);

                // Ch·∫°y quy tr√¨nh kh√¥i ph·ª•c
                const recoveryResponse = await fetch('/api/payment/recover-missing', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' }
                });

                const recoveryData = await recoveryResponse.json();

                if (recoveryData.success) {
                    console.log(`‚úÖ [AutoSync] Recovery completed: ${recoveryData.data?.recovered || 0}/${recoveryData.data?.total || 0} payments recovered`);

                    // Th√¥ng b√°o cho c√°c th√†nh ph·∫ßn kh√°c v·ªÅ vi·ªác kh√¥i ph·ª•c ho√†n t·∫•t
                    const recoveryEvent = new CustomEvent('paymentRecoveryUpdate', {
                        detail: {
                            timestamp: new Date().toISOString(),
                            total: recoveryData.data?.total || 0,
                            recovered: recoveryData.data?.recovered || 0
                        }
                    });
                    window.dispatchEvent(recoveryEvent);
                } else {
                    console.error('‚ùå [AutoSync] Recovery process failed:', recoveryData.error);
                }
            } else {
                console.log('‚úÖ [AutoSync] No payments need recovery at this time');
            }
        } catch (error) {
            console.error('‚ùå [AutoSync] Error during recovery process:', error);
        }
    };

    // ƒê·ªìng b·ªô theo l·ªãch tr√¨nh
    useEffect(() => {
        console.log('üöÄ [AutoSync] AutoPaymentSync component mounted');

        // ƒê·ªìng b·ªô ngay khi component ƒë∆∞·ª£c mount
        checkAndSyncSpecificPayment();

        // Ki·ªÉm tra URL ngay khi component ƒë∆∞·ª£c mount
        checkAndSyncSpecificPayment();

        // ƒê·ªìng b·ªô t·ª± ƒë·ªông m·ªói 8 gi√¢y (thay v√¨ 10 gi√¢y)
        const interval = setInterval(checkAndSyncSpecificPayment, 8000);

        // Cleanup khi component unmount
        return () => {
            console.log('üõë [AutoSync] AutoPaymentSync component unmounted');
            clearInterval(interval);
        };
    }, []);

    // Monitor location change to check for order_code parameter
    useEffect(() => {
        if (typeof window !== 'undefined') {
            const handleLocationChange = () => {
                checkAndSyncSpecificPayment();
            };

            // Listen for popstate event (back/forward navigation)
            window.addEventListener('popstate', handleLocationChange);

            return () => {
                window.removeEventListener('popstate', handleLocationChange);
            };
        }
    }, []);

    // Component t·ª± ƒë·ªông ƒë·ªìng b·ªô n√†y kh√¥ng hi·ªÉn th·ªã UI
    return null;
}
